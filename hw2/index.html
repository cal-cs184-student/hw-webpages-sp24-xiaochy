<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
	<style>
		body {
			background-color: rgb(255, 255, 255);
			padding: 100px;
			width: 1000px;
			margin: auto;
			text-align: left;
			font-weight: 300;
			font-family: 'Open Sans', sans-serif;
			color: #121212;
		}

		h1,
		h2,
		h3,
		h4 {
			font-family: 'Source Sans Pro', sans-serif;
		}

		kbd {
			color: #121212;
		}
		
  .row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between; /* 使列之间均匀分布 */
  }
  .column {
    flex: 0 0 40%; /* 列的宽度为父容器的40%，但不会收缩或增长 */
    margin-bottom: 20px; /* 可选：添加底部间距 */
  }

	</style>
	<title>CS 184 Mesh Edit</title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

	<script>
		MathJax = {
			tex: {
				inlineMath: [['$', '$'], ['\\(', '\\)']]
			}
		};
	</script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

</head>


<body>

	<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
	<h1 align="middle">Project 2: Mesh Edit</h1>
	<h2 align="middle">YOUR NAME</h2>

	<br><br>

	<div>

		<h2 align="middle">Overview</h2>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

		<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


		<b>
			Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your
			choosing. Use this Bezier curve for your screenshots below.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<!-- Example of including a single figure -->
		<div align="middle">
			<img src="images/your_file.png" align="middle" width="50%">
		</div>
		<br>

		<b>
			Show screenshots of each step / level of the evaluation from the original control points down to the final
			evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve
			as well.
		</b>
		<!-- Example of including multiple figures -->
		<div align="middle">
			<table style="width:100%">
				<tr align="center">
					<td>
						<img src="images/your_file.png" align="middle" width="400px" />
						<figcaption>Level 0</figcaption>
					</td>
					<td>
						<img src="images/your_file.png" align="middle" width="400px" />
						<figcaption>Level 1</figcaption>
					</td>
				</tr>
				<br>
				<tr align="center">
					<td>
						<img src="images/your_file.png" align="middle" width="400px" />
						<figcaption>Level 2</figcaption>
					</td>
					<td>
						<img src="images/your_file.png" align="middle" width="400px" />
						<figcaption>Level 3</figcaption>
					</td>
				</tr>
				<br>
				<tr align="center">
					<td>
						<img src="images/your_file.png" align="middle" width="400px" />
						<figcaption>Level 4</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<br>


		<b>
			Show a screenshot of a slightly different Bezier curve by moving the original control points around and
			modifying the parameter \(t\) via mouse scrolling.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
		<b>
			Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to
			evaluate Bezier surfaces.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

		<b>
			Briefly explain how you implemented the area-weighted vertex normals.
		</b>
		<p>
		<ul>
			<li>Firstly, we traversed all the triangles that torch this vertex and skipped the triangle which is in the
				boundary. </li>
			<li>Secondly, we calculated the area of each triangle by finding three vertices of this triangle,
				constructing two vectors AB, AC and using \(S_{\Delta} = \frac{1}{2}|AB \times AC|\). </li>
			<li>Thirdly, we used the cross product \(AB \times AC\) calculated above as the normal vector of this triangle
				face.</li>
			<li>Finally, we let areas of triangles as weights and calculated the area-weighted normals of all these
				triangles, which is the normal vector of this vertex.</li>
		</ul>
		</p>
		<br>


		<b>
			Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use
			<kbd>Q</kbd> to toggle default flat shading and Phong shading.
		</b>
		<p>
		<div class="row">
			<div class="column">
				<img src="part3_1.png" alt="Teapot shading without vertex normals" style="width:100%">
				<figcaption><b>Teapot shading without vertex normals</b></figcaption>
			</div>
			<div class="column">
				<img src="part3_2.png" alt="Teapot shading with vertex normals" style="width:100%">
				<figcaption><b>Teapot shading with vertex normals</b></figcaption>
			</div>
		</div>

		</p>
		<br>


		<h3 align="middle">Part 4: Edge Flip</h3>
		<b>
			Briefly explain how you implemented the edge flip operation and describe any interesting implementation /
			debugging tricks you have used.
		</b>
		<p>
			We started with the basic edge flip model, which is composed of two triangles and we tried to implement flip
			on it by changing the pointers in each element.
			There are four kinds of elements: vertex, halfedge, edge and face. In this basic model, we have 4 vertices,
			6 halfedges(including the halfedges before filpping and after flipping), 6 edges and 2 faces.
			Additionally, before we started, we checked whether the edge is a boundary. If so, we will do nothing on it.
		<ul>
			<li>Firstly, since "face" has one private variable -- halfedge, we changed the halfedge to ensure that the
				halfedge represents the correct triangle after edge flipping.</li>
			<li>Secondly, since "vertex" has one private variable -- halfedge, we changed the halfedge to ensure that
				even if the orignal halfedge of the vertex is flipped, the vertex can still have the valid halfedge.
			</li>
			<li>Thirdly, since "halfedge" has five private variables -- next, twin, vertex, edge and face, we changed
				them correspondingly to ensure correctness. It's worth mentioning that we changed four halfedges not
				flipped first and then changed the flipped halfedge.
				Since we need to use the properties of the flipped halfedges to update the other halfedges' variables.
			</li>
			<li>Finally, since "edge" has one private variables -- halfedge, we just change the halfedge of the flipped
				edge to the halfedge after flipping it.</li>
		</ul>
		</p>
		<br>


		<b>
			Show screenshots of the teapot before and after some edge flips.
		</b>
		<p>
		<div class="row">
			<div class="column">
				<img src="part4_1_1.png" alt="Flip edge example 1" style="width:100%">
				<figcaption>Flip edge example 1: Before flip</figcaption>
			</div>
			<div class="column">
				<img src="part4_1_2.png" alt="Flip edge example 1" style="width:100%">
				<figcaption><b>Flip edge example 1: After flip</b></figcaption>
			</div>
		</div>

		<div class="row">
			<div class="column">
				<img src="part4_2_1.png" alt="Flip edge example 2" style="width:100%">
				<figcaption><b>Flip edge example 2: Before flip</b></figcaption>
			</div>
			<div class="column">
				<img src="part4_2_2.png" alt="Flip edge example 2" style="width:100%">
				<figcaption><b>Flip edge example 2: After flip</b></figcaption>
			</div>
		</div>
		<div class="row">
			<div class="column">
				<img src="part4_3_1.png" alt="Flip edge example 3" style="width:100%">
				<figcaption><b>Flip edge example 3: Before flip</b></figcaption>
			</div>
			<div class="column">
				<img src="part4_3_2.png" alt="Flip edge example 3" style="width:100%">
				<figcaption><b>Flip edge example 3: After flip</b></figcaption>
			</div>
		</div>
		</p>
		<br>


		<b>
			Write about your eventful debugging journey, if you have experienced one.
		</b>
		<p>
			At first, we accidentally changed the properties of the flipped edge first instead of first using its
			properties to change the properties of other elements.
		</p>
		<br>


		<h3 align="middle">Part 5: Edge Split</h3>
		<b>
			Briefly explain how you implemented the edge split operation and describe any interesting implementation /
			debugging tricks you have used.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Show screenshots of a mesh before and after some edge splits.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Write about your eventful debugging journey, if you have experienced one.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			If you have implemented support for boundary edges, show screenshots of your implementation properly
			handling split operations on boundary edges.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
		<b>
			Briefly explain how you implemented the loop subdivision and describe any interesting implementation /
			debugging tricks you have used.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Take some notes, as well as some screenshots, of your observations on how meshes behave after loop
			subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some
			edges?
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes
			slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so
			that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how
			your pre-processing helps alleviate the effects.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			If you have implemented any extra credit extensions, explain what you did and document how they work with
			screenshots.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
		<b>
			Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh
			in your write-up.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Include a series of screenshots showing your original mesh and your mesh after one and two rounds of
			subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as
			well.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


</body>

</html>