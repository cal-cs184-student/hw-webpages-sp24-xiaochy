<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
	<style>
		body {
			background-color: rgb(255, 255, 255);
			padding: 100px;
			width: 1000px;
			margin: auto;
			text-align: left;
			font-weight: 300;
			font-family: 'Open Sans', sans-serif;
			color: #121212;
		}

		h1,
		h2,
		h3,
		h4 {
			font-family: 'Source Sans Pro', sans-serif;
		}

		kbd {
			color: #121212;
		}
		
  .row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between; /* 使列之间均匀分布 */
  }
  .column {
    flex: 0 0 40%; /* 列的宽度为父容器的40%，但不会收缩或增长 */
    margin-bottom: 20px; /* 可选：添加底部间距 */
  }

	</style>
	<title>CS 184 Mesh Edit</title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

	<script>
		MathJax = {
			tex: {
				inlineMath: [['$', '$'], ['\\(', '\\)']]
			}
		};
	</script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

</head>


<body>

	<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
	<h1 align="middle">Project 2: Mesh Edit</h1>
	<h2 align="middle">YOUR NAME</h2>

	<br><br>

	<div>

		<h2 align="middle">Overview</h2>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

		<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


		<b>
			Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
		</b>
		<p>
			The de Casteljau's algorithm is a way we used to evaluate the Bezier cruves. It starts with a few control points
			and provides a pyramid of coefficients by doing linear interpolation between adjacent points at each level. We implement 
			<code>BezierCurve::evaluateStep(...)</code> to perform the algorithm. The function doesnt't give the final coefficients 
			right away. Instead, it evaluates the coefficients at each step. We loop through all control points at the current step, 
			perform linear interpolation between adjacent points, and return a list of coefficients at this step.
		</p>
		<br>
		<b>
			Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your
			choosing. Use this Bezier curve for your screenshots below.
		</b>
		<p>
		</p>
		<!-- Example of including a single figure -->
		<div align="middle">
			<img src="images/part1.2.pic.jpg" align="middle" width="50%">
		</div>
		<br>

		<b>
			Show screenshots of each step / level of the evaluation from the original control points down to the final
			evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve
			as well.
		</b>
		<!-- Example of including multiple figures -->
		<div align="middle">
			<table style="width:100%">
				<tr align="center">
					<td>
						<img src="images/part1_level1.pic.jpg" align="middle" width="400px" />
						<figcaption>Level 1</figcaption>
					</td>
					<td>
						<img src="images/part1_level2.pic.jpg" align="middle" width="400px" />
						<figcaption>Level 2</figcaption>
					</td>
				</tr>
				<br>
				<tr align="center">
					<td>
						<img src="images/part1_level3.pic.jpg" align="middle" width="400px" />
						<figcaption>Level 3</figcaption>
					</td>
					<td>
						<img src="images/part1_level4.pic.jpg" align="middle" width="400px" />
						<figcaption>Level 4</figcaption>
					</td>
				</tr>
				<br>
				<tr align="center">
					<td>
						<img src="images/part1_level5.pic.jpg" align="middle" width="400px" />
						<figcaption>Level 5</figcaption>
					</td>
					<td>
						<img src="images/part1_level6.pic.jpg" align="middle" width="400px" />
						<figcaption>Level 6</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<br>


		<b>
			Show a screenshot of a slightly different Bezier curve by moving the original control points around and
			modifying the parameter \(t\) via mouse scrolling.
		</b>
		<p>
			<div align="middle">
				<table style="width:100%">
					<tr align="center">
						<td>
							<img src="images/part1.4_change_t.pic.jpg" align="middle" width="400px" />
							<figcaption>Change t</figcaption>
						</td>
						<td>
							<img src="images/part1.4_change_pts.pic.jpg" align="middle" width="400px" />
							<figcaption>Move the control points</figcaption>
						</td>
					</tr>
				</table>
			</div>
		</p>
		<br>


		<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
		<b>
			Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to
			evaluate Bezier surfaces.
		</b>
		<p>
			We can extend the de Casteljau algorithm to 3D surfces, simply by applying the algorithm separately in u-direction and 
			v direction. Below is a step-by-step instruction.
			<ul>
				<li>
					To evaluate our Bazier surface, we first implement <code>BezierPatch::evaluate1D(...)</code>, which evaluates the final 
					coefficient on the top of the pyramid in u-direction in 1D.
				</li>
				<li>
					Next, we implement <code>BezierPatch::evaluate(...)</code>. This function calls <code>BezierPatch::evaluate1D(...)</code>
					at each iteration step to evaluate one "moving curve" in u-direction. Using this 1D "moving" curves, we evaluate the surface
					in v-direction.
				</li>
			</ul>
		</p>
		<br>

		<b>
			Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
		</b>
		<p>
			<div align="middle">
				<img src="images/part2.jpg" align="middle" width="50%">
			</div>
		</p>
		<br>


		<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

		<b>
			Briefly explain how you implemented the area-weighted vertex normals.
		</b>
		<p>
		<ul>
			<li>Firstly, we traversed all the triangles that torch this vertex and skipped the triangle which is in the
				boundary. </li>
			<li>Secondly, we calculated the area of each triangle by finding three vertices of this triangle,
				constructing two vectors AB, AC and using \(S_{\Delta} = \frac{1}{2}|AB \times AC|\). </li>
			<li>Thirdly, we used the cross product \(AB \times AC\) calculated above as the normal vector of this triangle
				face.</li>
			<li>Finally, we let areas of triangles as weights and calculated the area-weighted normals of all these
				triangles, which is the normal vector of this vertex.</li>
		</ul>
		</p>
		<br>


		<b>
			Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use
			<kbd>Q</kbd> to toggle default flat shading and Phong shading.
		</b>
		<p>
		<div class="row">
			<div class="column">
				<img src="part3_1.png" alt="Teapot shading without vertex normals" style="width:100%">
				<figcaption><b>Teapot shading without vertex normals</b></figcaption>
			</div>
			<div class="column">
				<img src="part3_2.png" alt="Teapot shading with vertex normals" style="width:100%">
				<figcaption><b>Teapot shading with vertex normals</b></figcaption>
			</div>
		</div>

		</p>
		<br>


		<h3 align="middle">Part 4: Edge Flip</h3>
		<b>
			Briefly explain how you implemented the edge flip operation and describe any interesting implementation /
			debugging tricks you have used.
		</b>
		<p>
			We started with the basic edge flip model, which is composed of two triangles and we tried to implement flip
			on it by changing the pointers in each element.
			There are four kinds of elements: vertex, halfedge, edge and face. In this basic model, we have 4 vertices,
			6 halfedges(including the halfedges before filpping and after flipping), 6 edges and 2 faces.
			Additionally, before we started, we checked whether the edge is a boundary. If so, we will do nothing on it.
		<ul>
			<li>Firstly, since "face" has one private variable -- halfedge, we changed the halfedge to ensure that the
				halfedge represents the correct triangle after edge flipping.</li>
			<li>Secondly, since "vertex" has one private variable -- halfedge, we changed the halfedge to ensure that
				even if the orignal halfedge of the vertex is flipped, the vertex can still have the valid halfedge.
			</li>
			<li>Thirdly, since "halfedge" has five private variables -- next, twin, vertex, edge and face, we changed
				them correspondingly to ensure correctness. It's worth mentioning that we changed four halfedges not
				flipped first and then changed the flipped halfedge.
				Since we need to use the properties of the flipped halfedges to update the other halfedges' variables.
			</li>
			<li>Finally, since "edge" has one private variables -- halfedge, we just change the halfedge of the flipped
				edge to the halfedge after flipping it.</li>
		</ul>
		</p>
		<br>


		<b>
			Show screenshots of the teapot before and after some edge flips.
		</b>
		<p>
		<div class="row">
			<div class="column">
				<img src="part4_1_1.png" alt="Flip edge example 1" style="width:100%">
				<figcaption>Flip edge example 1: Before flip</figcaption>
			</div>
			<div class="column">
				<img src="part4_1_2.png" alt="Flip edge example 1" style="width:100%">
				<figcaption><b>Flip edge example 1: After flip</b></figcaption>
			</div>
		</div>

		<div class="row">
			<div class="column">
				<img src="part4_2_1.png" alt="Flip edge example 2" style="width:100%">
				<figcaption><b>Flip edge example 2: Before flip</b></figcaption>
			</div>
			<div class="column">
				<img src="part4_2_2.png" alt="Flip edge example 2" style="width:100%">
				<figcaption><b>Flip edge example 2: After flip</b></figcaption>
			</div>
		</div>
		<div class="row">
			<div class="column">
				<img src="part4_3_1.png" alt="Flip edge example 3" style="width:100%">
				<figcaption><b>Flip edge example 3: Before flip</b></figcaption>
			</div>
			<div class="column">
				<img src="part4_3_2.png" alt="Flip edge example 3" style="width:100%">
				<figcaption><b>Flip edge example 3: After flip</b></figcaption>
			</div>
		</div>
		</p>
		<br>


		<b>
			Write about your eventful debugging journey, if you have experienced one.
		</b>
		<p>
			At first, we accidentally changed the properties of the flipped edge first instead of first using its
			properties to change the properties of other elements.
		</p>
		<br>


		<h3 align="middle">Part 5: Edge Split</h3>
		<b>
			Briefly explain how you implemented the edge split operation and describe any interesting implementation /
			debugging tricks you have used.
		</b>
		<p>
			Unlike the edge flip operation, the edge split operation involves dividing the input edge at the midpoint and connect 
			the two unshared vertices in the two adjacent triangles, which requires creating new edges, halfedges, faces, and the 
			midpoint vertex. 
			<ul>
				<li>
					In the basic case with two adjacent triangles sharing one edge and two vertices, we need to add three more edges: $e_1$, $e_2$, and $e_3$. 
					Combined with the original edge $e_0$, they become the four inner edges that split the two traingles into four. Also, we need to initialize 
					<code>isNew</code> value of the new edges. For $e_2$ and $e_3$, we set <code>isNew = true</code> because they are edges that doesn't exist 
					in the mesh before. However, for $e_0$ and $e_1$, we set <code>isNew = false</code>, since they overlap with the original edge.
				</li>
				<li>	
					We also need to add two halfedges for each of the newly created edge. For $e_0$, its halfedges already exist, so we do nothing for now.
					For $e_1$, $e_2$, and $e_3$, we create in total six halfedges, two for each pointing into opposite directions.
				</li>
				<li>
					Now we have four triangles, meaning that we have four faces. Thus, we need to add two more faces.
				</li>
				<li>
					Lastly, we add a new vertex m at the midpoint of $e_0$. Its position would be the average position of the vertices at the two ends of $e_0$.
				</li>
			</ul>
			Once these items are added, it's crucial to reassign pointers for all elements within the original two triangles, encompassing 
			both the newly created ones and the existing ones—even if they are not directly updated in this particular step. A useful debugging 
			approach involves checking for any elements that haven't had their values reassigned to ensure the completeness of the reassignment process.
		</p>
		<br>

		<b>
			Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
		</b>
		<p>
			<div align="middle">
				<table style="width:100%">
					<tr align="center">
						<td>
							<img src="images/part5.2.pic.jpg" align="middle" width="300px" />
							<figcaption>Before splitting</figcaption>
						</td>
						<td>
							<img src="images/part5.2_split1.pic.jpg" align="middle" width="300px" />
							<figcaption>Split one edge</figcaption>
						</td>
						<td>
							<img src="images/part5.2_split2.pic.jpg" align="middle" width="300px" />
							<figcaption>Split multiple edges</figcaption>
						</td>
					</tr>
				</table>
			</div>
		<br>
		<b>
			Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
		</b>
		<p>
			<div align="middle">
				<table style="width:100%">
					<tr align="center">
						<td>
							<img src="images/part5.3.pic.jpg" align="middle" width="400px" />
							<figcaption>Before splitting and flipping</figcaption>
						</td>
						<td>
							<img src="images/part5.3_splitflip.pic.jpg" align="middle" width="400px" />
							<figcaption>Split and flip multiple edges</figcaption>
						</td>
					</tr>
				</table>
			</div>
		</p>
	
		<b>
			Write about your eventful debugging journey, if you have experienced one.
		</b>
		<p>
			Initially, our operation functioned correctly, but it started causing a segmentation fault when we attempted 
			to split a large number of edges. We eventually realized that updating the halfedges within the "boundary" (not the boundary of the mesh) of the 
			two original triangles wasn't sufficient. We also needed to handle their twins—the halfedges outside the "boundary"—to 
			resolve the segmentation fault issue.
		</p>
		<br>


		<b>
			If you have implemented support for boundary edges, show screenshots of your implementation properly
			handling split operations on boundary edges.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
		<b>
			Briefly explain how you implemented the loop subdivision and describe any interesting implementation /
			debugging tricks you have used.
		</b>
		<p>
			<ul>
				<li>
					The first step is to set <code>isNew = false</code> for all edges and vertices of the mesh. This would avoid splitting 
					and flipping wrong edges when we keep upsampling.
				</li>
				<li>
					The next step is to iterate through all vertices <code>v</code> and calculate the new positions for them. We store these 
					values in <br> <code>v->newPosition</code>. 
				</li>
				<li>
					Then, we iterate through all edges <code>e</code>, calculate the positions for all new vertices that we are going to add, and 
					store the position values in <code>e->newPosition</code>.
				</li>
				<li>
					Next, we perform edge split. We iterate through all edges and only split those connecting two old vertices (<code>v->isNew = false</code>) 
					At this step, a bunch of new vertices are created. For each newly created v at the midpoint of edge e, we assign <code>e->newPosition</code> 
					to <code>v->newPosition</code>.
				</li>
				<li>
					After splitting edges, we flip all new edges (<code>e->isNew = true</code>) that connecting exactly one old vertex and one new vertex
					<br>(<code>v1->isNew + v2->isNew == 1</code>).
				</li>
				<li>
					Finally, we copy <code>v->newPosition</code> to <code>v->position</code> for every vertex v currently in the mesh.
				</li>
			</ul>
		</p>
		<br>


		<b>
			Take some notes, as well as some screenshots, of your observations on how meshes behave after loop
			subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some
			edges?
		</b>
		<p>
			We observe that the sharp corners and edges totally disappear after loop subdivision. Here, the torus
			with six corners become a smooth circle ring. If we pre-split the edges on the sharp corners, the 
			mesh somehow preserve its shape.
		<div align="middle">
			<table style="width:100%">
				<tr align="center">
					<td>
						<img src="images/part6.2.2.pic.jpg" align="middle" width="400px" />
						<figcaption>Without pre-splitting</figcaption>
					</td>
					<td>
						<img src="images/part6.2.1.pic.jpg" align="middle" width="400px" />
						<figcaption>Loop subdivision without pre-splitting</figcaption>
					</td>
				</tr>
				<tr align="center">
					<td>
						<img src="images/part6.2.3.pic.jpg" align="middle" width="400px" />
						<figcaption>With pre-splitting</figcaption>
					</td>
					<td>
						<img src="images/part6.2.4.pic.jpg" align="middle" width="400px" />
						<figcaption>Loop subdivision with pre-splitting</figcaption>
					</td>
				</tr>
			</table>
		</div>
	
		</p>
		<br>


		<b>
			Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes
			slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so
			that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how
			your pre-processing helps alleviate the effects.
		</b>
		<p>
			The strange asymmetry observed during cube subdivision is, in fact, an inherent outcome of the mesh's triangulation. 
			It's noteworthy that the underlying geometry divides each face along a single diagonal, resulting in a specific orientation 
			for the initial triangles. Consequently, as these triangles undergo subdivision, the new triangles maintain the same orientation 
			as the original ones. Thus, the asymmetry is established during the initial round of subdivision and preserves as we continue upsampling.
			<div align="middle">
				<table style="width:100%">
					<tr align="center">
						<td>
							<img src="images/part6.3.1.pic.jpg" align="middle" width="400px" />
							<figcaption>Without pre-splitting</figcaption>
						</td>
						<td>
							<img src="images/part6.3.2.pic.jpg" align="middle" width="400px" />
							<figcaption>Loop subdivision without pre-splitting</figcaption>
						</td>
					</tr>
				</table>
			</div>
			To address this issue, we simply pre-split all diagonal edges. As a result, we now have triangles in different orientations, 
			contributing to preserve the symmetry.
			<div align="middle">
				<table style="width:100%">
					<tr align="center">
						<td>
							<img src="images/part6.3.3.pic.jpg" align="middle" width="400px" />
							<figcaption>With pre-splitting</figcaption>
						</td>
						<td>
							<img src="images/part6.3.4.pic.jpg" align="middle" width="400px" />
							<figcaption>Loop subdivision with pre-splitting</figcaption>
						</td>
					</tr>
				</table>
			</div>
		</p>
		<br>


		<b>
			If you have implemented any extra credit extensions, explain what you did and document how they work with
			screenshots.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
		<b>
			Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh
			in your write-up.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Include a series of screenshots showing your original mesh and your mesh after one and two rounds of
			subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as
			well.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


		<b>
			Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
		</b>
		<p>
			YOUR RESPONSE GOES HERE
		</p>
		<br>


</body>

</html>