<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Chuyang Xiao, Claire Fang</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
  In this assignment, we successfully implemented various techniques, including pixel sampling, 
  supersampling, transforms, barycentric coordinates, texture mapping, and level sampling. 
  The primary objective was to gain insights into how different techniques work and understand 
  the benefits and trade-offs among different sampling methods. It's fascinating to observe how 
  supersampling and level sampling contribute to improved antialiasing. Furthermore, we recognize 
  the practical significance of barycentric coordinates, as they facilitate the calculation of various 
  properties for a point within a triangle, given the corresponding values of the triangle's three vertices.
</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p><b>1. Step-by-step Walkthrough </b></p>
	<p> To determine whether each pixel on the frame buffer is inside a given triangle:</p>
	<ul>
		<li>Traversing the entire frame buffer proves inefficient due to its large size, resulting in slow processing. 
      To address this, we begin by calculating the bounding box for each triangle based on its three vertices. 
      Subsequently, we assess whether each pixel within the bounding box resides inside the triangle. To simplify pixel 
      traversal, we approximate the coordinates of the bounding box boundaries and cast to integers with floor function. Moreover, 
      we designate the midpoint coordinates of each pixel as the point to be evaluated within the function <code>inside()</code>, 
      determining whether the pixel is inside the triangle.
    </li>
		<li>Next, we determine whether the vertices of the given triangle are in clockwise or counterclockwise order. We
			achieve this by calculating the <b>cross product</b> of vector AB and vector AC, where A, B, and C
      represent the vertices of the triangle. If the cross product is negative, it indicates a clockwise order; otherwise, 
      the vertices are in a counterclockwise order.
    </li>
		<li>Furthermore, we employ the three-line test. For vertices in clockwise order, a negative result indicates the pixel 
      is inside the triangle. Conversely, for vertices in counterclockwise order, a positive result signifies the pixel's 
      inclusion within the triangle.
    </li>
		<li>If the pixel is inside the triangle, we fill the desgnated color into the corresponding position in the sample
			buffer. (Note: In Task 1, where super-sampling is not yet applied, the frame buffer size aligns with the sample buffer size.)
    </li>
		<li>Finally, in the <code>resolve_to_framebuffer()</code> function, we directly transfer the colors from the
			sample buffer to the <b>rgb_framebuffer_target</b>. This allows the colors to be displayed on the screen.
		</li>
	</ul>
	<p><b>2. Algorithm Efficiency</b> </p>
	<p> As our algorithm only traverses the bounding box of the triangle rather than the entire frame buffer, its efficiency is 
    essentially equivalent to checking each sample within the bounding box of the triangle.</p>
	<p> <b>3. Image Gallery</b></p>
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/task1.png" align="middle" width="600px"/>
          <figcaption align="middle">Rasterize triangle without supersampling</figcaption>
        </td>
      </tr>
    </table>
  </div>
	


<h3 align="middle">Part 2: Antialiasing triangles</h3>
<p> <b>1. Importance and Implementation</b></p>
	<p>As described in lecture, supersampling is an effective antialiasing approach. The basic idea is to render the 
		each pixel in the screen space into several samples, then downsample back by averaging the values of the samples.
		This helps us to make smoother edges of triangles, reduing aliasing errors.
	<ul>
		<li>To implement supersampling, we first resize the sample_buffer to store extra samples inside each pixel. In task 1, 
			sample_buffer has the same size as frame_buffer. For task 2, we have width * height pixels and sample_rate samples 
			inside each pixel, which requires <code>sample_buffer</code>'s size of <code>(width * height * sample_rate)</code>.</li>
		<li>Another change, compared with task 1, is to estiate each pixel's value by averaging the value of samples within 
			the pixel. We compute the average and write each pixel's value into <code>resolve_to_framebuffer</code>.</li></ul>
	<p> <b>2. Results</b></p>
	<style>	
		figure {
			border: 1px #cccccc solid;
			padding: 4px;
			margin: auto;
		}
		figcaption {
			/* background-color: black; */
			/* color: white; */
			font-style: italic;
			padding: 2px;
			text-align: center;
		}
		.column {
			float: left;
			width: 30%;
			padding: 5px;
		}
		.row::after {
			content: "";
			clear: both;
			display: table;
		}
	</style>
	<div class="row">
		<div class="column">
			<img src="images/task2_rate1.png" alt="Sample rate = 1" style="width:100%">
			<figcaption>sample rate = 1</figcaption>
		</div>
		<div class="column">
			<img src="images/task2_rate4.png" alt="Sample rate = 4" style="width:100%">
			<figcaption>sample rate = 4</figcaption>
		</div>
		<div class="column">
			<img src="images/task2_rate16.png" alt="Sample rate = 16" style="width:100%">
			<figcaption>sample rate = 16</figcaption>
		</div>	
	</div>
	In the images provided above, the impact of sample rate on edge smoothness is evident. At a sample rate of 1, discernible 
	jaggies are observed, attributed to marking each pixel inside the triangle with the same color. However, as the sampling 
	rate increases, we sample multiple locations within each pixel, subsequently averaging their values. This results in a 
	noticeable improvement, particularly along the edges, where pixels are no longer assigned uniform values. Instead, they 
	exhibit a smoother and blurrier appearance.


<h3 align="middle">Part 3: Transforms</h3>
<p>We attempted to lift the robot's spirits by rotating its arms and legs, hoping to bring a cheerful and 
  dynamic vibe to its appearance. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task3.png" align="middle" width="600px"/>
        <figcaption align="middle">A robot cheering up</figcaption>
      </td>
    </tr>
  </table>
</div>


<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>
<p> <b>1. Illustration of Barycentric Coordinates</b></p>
	<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">

		<!-- Define a linear gradient -->
		<defs>
		  <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
			<stop offset="0%" style="stop-color: red; stop-opacity: 1" />
			<stop offset="50%" style="stop-color: green; stop-opacity: 1" />
			<stop offset="100%" style="stop-color: blue; stop-opacity: 1" />
		  </linearGradient>
		</defs>
	
		<!-- Create an equilateral triangle with the blended gradient -->
		<polygon points="100,10 10,190 190,190" style="fill: url(#gradient);" />
	
	</svg>
	<p>The plot above illustrates the functioning of barycentric coordinates. Assigning red, green, 
		and blue to the three vertices of the triangle respectively, the colors inside the triangle 
		result from a blend of these vertex colors. The color at each sample point is calculated 
		based on its barycentric coordinate: \( C_p = \alpha C_A + \beta C_B + \gamma C_C \). \( \alpha,
		\beta, \gamma\) are obtained based on the proportional distances, and they linearly interpolate
		values at vertices.</p>
	<p> <b>2. Results</b></p>
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/task4.png" align="middle" width="600px"/>
          <figcaption align="middle">Test 7</figcaption>
        </td>
      </tr>
    </table>
  </div>
  


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>
<p><b>1. Pixel Sampling</b></p>
In pixel samping, we usually sample one point per pixel. The color of the pixel is determined by the single sample. 
Below decribes how to implement it to perform texture sampling.
	<ul>
		<li>Firstly, given the coordinates of the three vertices of the triangle on the frame buffer and the coordinates
			of a point inside the triangle, we calculate the Barycentric coordinates \(\alpha\),\(\beta\),\(\gamma\) = 1 - \(\alpha\) - \(\beta\)
      by using linear interpolation.
    </li>
		<li>Secondly, with the corresponding coordinates of the three triangle vertices in texture space, we can 
      use the previously calculated \(\alpha\), \(\beta\), \(\gamma\) and scale by the size of the texture space
      to determine the texture coordinates of the internal point.
    </li>
		<li>Since the mapping coordinates on the texture may not be integers, we cannot directly obtain the color
			corresponding to the sample. Hence, we have two approximation methods: <code>sample_nearest()</code> and
			<code>sample_bilinear()</code>.
		</li>
		<li> <b>Two sampling methods</b>
			<ul>
				<li><code>sample_nearest()</code>: find the nearest point to the sample in the texture space assign 
          the color of that point to our sample.</li>
				<li><code>sample_bilinear()</code>: find the four nearest points to our sample in the texture space and 
          use bilinear interpolation to calculate the color of the sample.
				</li>
			</ul>
		</li>
	</ul>
	<p><b>2. Image Gallery</b></p>
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/task5_rate1_nearest.png" align="middle" width="500px"/>
          <figcaption align="middle">Nearest samping with sample rate = 1</figcaption>
        </td>
        <td>
          <img src="images/task5_rate1_bilinear.png" align="middle" width="500px"/>
          <figcaption align="middle">Bilinear samping with sample rate = 1</figcaption>
        </td>
      </tr>
      <br>
      <tr>
        <td>
          <img src="images/task5_rate16_nearest.png" align="middle" width="500px"/>
          <figcaption align="middle">Nearest samping with sample rate = 16</figcaption>
        </td>
        <td>
          <img src="images/task5_rate16_bilinear.png" align="middle" width="500px"/>
          <figcaption align="middle">Bilinear samping with sample rate = 16</figcaption>
        </td>
      </tr>
    </table>
  </div>
	<p><b>3. Differences between two sampling methods</b></p>
	<ul>
		<li>When the sample rate is low, bilinear sampling outperforms nearest sampling. Due to the small sample 
      size, bilinear sampling is essential to utilize colors from surrounding points on the texture, creating 
      a smoother appearance. Relying solely on the nearest point can result in a sharper, less visually appealing image.
    </li>
		<li>At a high sample rate, the distinction between the two sampling methods is minimal. With a large number 
      of samples, even assigning each sample the nearest point's color generates a smooth visual appearance.
    </li>

<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<p> <b>1. Level Sampling and Its Implementation </b></p>
<p>a. Level Sampling </p>
<p>Level sampling is employed to enhance texture mapping and minimize antialiasing artifacts. By mipmapping at suitable levels, a lower-resolution image is generated. The continuous positive nature of the level allows for two estimation approaches: selecting the nearest integer level or performing linear interpolation between two levels. The latter provides a smoother transition between levels and can mitigate certain artifacts associated with abrupt level changes.</p>
<p>b. Implementation Details</p>
<ul>
  <li>Firstly, we use the same method described in Task 5 to calculate the texture coordinate of the sample <b>\((x,y)\)</b> and 
  its neighbours <b>\((x+1,y), (x,y+1)\)</b>, from which we get <b>\((u,v), (u_dx,v_dx), (u_dy,v_dy)\)</b>. </li>
  <li>Secondly, we calculate <b>\(\frac{du}{dx}\),\(\frac{dv}{dx}\),\(\frac{du}{dy}\),\(\frac{du}{dy}\)</b>by 
  <b>\(u-u_dx, v-v_dx, u-u_dy, v-v_dy\)</b>. After that, we can use <b>\(L = \max{(\sqrt{({\frac{du}{dx}})^2 + ({\frac{dv}{dx}})^2}, \sqrt{({\frac{du}{dy}})^2 + ({\frac{dv}{dy}})^2})}\) </b> and
<b>\(D = \log_2L\)</b> to calculate the mipmap level D.</li>
<li>Thirdly, since we have three level sampling methods: <b>L_ZERO, L_NEAREST, L_LINEAR</b>, we implement them in 
<code>Texture::sample()</code>. For <b>L_ZERO</b>, we just use the zero-level mipmap's color; For <b>L_NEAREST</b>, we use the integer nearest to D as the mipmap level and get the color from this mipmap;
For <b>L_LINEAR</b>, we use linear interpolation between the colors of two mipmap levels around D as the sample color.</li>
</ul>
<p> <b>2. Pixel Sampling, Level Samping and Supersampling</b></p>
<p>a. Speed</p>
<ul>
  <li> Pixel Sampling samples one point inside each pixel, which means we only need to obtain the color
    at one position per pixel. This technique is the fastest among three.
  </li>
  <li> Level Sampling renders a lower-resolution representation of the original image by using mipmaps, which
    improves the speed of the technique.
  </li>
  <li> Supersampling samples multiple points inside each pixel, which increases the computational work needed 
    for obtaining the color of a pixel. This makes it the slowest among three.
  </li>
</ul>
<p>b. Memory Usage</p>
<ul>
  <li> Pixel Sampling has the lowest memory requirements, as it only stores one color value per pixel.
  </li>
  <li> Level Sampling increases the memory usage as it needs extra space for a mipmap. According to the dicussion 
    worksheet, the storage of an entire mipmap is \(\frac{4}{3}x\), where \(x\) is the size of the original texture.
  </li>
  <li> Supersampling has memory usage proportional to the sample rate inside each pixel. It requires extra space
    to store the multiple samples per pixel.  
  </li>
</ul>
<p>c. Antialiasing Power</p>
<ul>
  <li> Pixel Sampling can lead to aliased artifact, so it has the least antialiasing power.
  </li>
  <li> Level Sampling reduces jaggies by using lower-resolution textures for distant objects, as shown in plots below.
    This helps smooth the edges and transitions.
  </li>
  <li> Supersampling is also a good antialiasing technique, as it calculate the value of color in one pixel by
    sampling at several positions and downsampling, which results in smoother edges.
  </li>
</ul>

<p> <b>3. Comparison between different methods</b></p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6_l0_nearest.png" align="middle" width="400px"/>
        <figcaption align="middle">L_ZERO, P_NEAREST</figcaption>
      </td>
      <td>
        <img src="images/task6_l0_bilinear.png" align="middle" width="400px"/>
        <figcaption align="middle">L_ZERO, P_LINEAR</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/task6_nearest_nearest.png" align="middle" width="400px"/>
        <figcaption align="middle">L_NEAREST, P_NEAREST</figcaption>
      </td>
      <td>
        <img src="images/task6_nearest_bilinear.png" align="middle" width="400px"/>
        <figcaption align="middle">L_NEAREST, P_LINEAR</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/task6_bilinear_nearest.png" align="middle" width="400px"/>
        <figcaption align="middle">L_LINEAR, P_NEAREST</figcaption>
      </td>
      <td>
        <img src="images/task6_bilinear_bilinear.png" align="middle" width="400px"/>
        <figcaption align="middle">L_LINEAR, P_LINEAR</figcaption>
      </td>
    </tr>
  </table>
</div>


<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
