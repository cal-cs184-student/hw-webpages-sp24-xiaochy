<meta http-equiv='cache-control' content='no-cache'>
<meta http-equiv='expires' content='0'>
<meta http-equiv='pragma' content='no-cache'>
<!DOCTYPE html>
<html>

<head>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<style>
		img {
			max-width: 600px;
		}
	</style>
</head>

<body>
	<h1><b> CS184 HW1: Rasterizer</b> </h1>
	<h2> <b>Task 1 </b></h2>
	<p><b>1. Walk through </b></p>
	<p> To determine whether each pixel on the frame buffer is inside a given triangle:</p>
	<ul>
		<li>First, since the entire frame buffer is too large, it's too slow to traverse it entirely. Therefore, we
			start
			by calculating the bounding box for each of the three triangles using their vertices.
			Then, we want to check whether each pixel within the bounding box is inside the triangle. We approximate the
			coordinates of the bounding box
			boundaries to integers using the floor function for easier traversal of pixels. Additionally,
			we consider the coordinates of each pixel's midpoint as the coordinates to be evaluated within the function
			to determine whether the pixel is inside the triangle.</li>
		<li>Next, we determine whether the vertices of the given triangle are in clockwise or counterclockwise order. We
			achieve this by calculating the cross product of Vector AB: <span>&#x2192;</span> and Vector AC: <span>&#x2192;</span>, where A, B, and C represent
			the vertices
			of the triangle.
			If the cross product is negative, it indicates a clockwise order; otherwise, it indicates a counterclockwise
			order.</li>
		<li>Furthermore, we use the three-line test. If the vertices are in clockwise order, the result of the
			three-line test should be negative for the pixel to be inside the triangle.
			Conversely, if the vertices are in counterclockwise order, the result of the three-line test should be
			positive for the pixel to be inside the triangle.</li>
		<li>If the pixel is inside the triangle, we fill the given color into the corresponding position of the sample
			buffer where the pixel resides. (In Task 1, as we haven't performed super-sampling yet, the size of the
			frame buffer equals the size of the sample buffer.)</li>
		<li>Finally, in the <code>resolve_to_framebuffer()</code> function, we directly transfer the colors from the
			sample buffer to the <b>rgb_framebuffer_target</b>. This allows the colors to be displayed on the screen.
		</li>
	</ul>
	<p><b>2. Algorithm Efficiency</b> </p>
	<p> Since our algorithm does not traverse the whole frame buffer, but just traverse the bounding box of the
		triangle, our algorithm equals to the one that checks each sample within the bounding box of the triangle.</p>
	<p> <b>3. Image Gallery</b></p>
	<figcaption><b>Rasterize triangle without supersampling</b></figcaption>
	<img src="image_1.png" alt="Rasterize triangle without supersampling">
	<h2> <b>Task 3</b></h2>
	<p>I tried to make the robot cheer up by doing the rotation to his arms and legs. </p>
	<figcaption><b>cheer-up robot</b></figcaption>
	<img src="image_2.png" alt="cheer-up robot">
	<h2> <b>Task 5 </b></h2>
	<p><b>1. Pixel Sampling</b></p>
	<ul>
		<li>Firstly, given the coordinates of the three vertices of the triangle on the frame buffer and the coordinates
			of an internal point of the triangle, we can calculate the Barycentric coordinates: \(\alpha\),\(\beta\), \(\gamma\) = 1 -
			\(\alpha\) - \(\beta\). </li>
		<li>Secondly, knowing the corresponding coordinates of the three vertices of the triangle on the texture, we can
			utilize the previously calculated \(\alpha\), \(\beta\), \(\gamma\) to calculate the coordinates of the internal point
			of the triangle on the texture using the Barycentric formula. </li>
		<li>Since the mapping coordinates on the texture may not be integers, we cannot directly obtain the color
			corresponding to the sample. Hence, we have two methods: <code>sample_nearest()</code> and
			<code>sample_bilinear()</code> to obtain the color corresponding to the sample.
		</li>
		<li> <b>Two sampling methods</b>
			<ul>
				<li><code>sample_nearest()</code>: This means we will find the nearest vertex on the texture to the
					sample texture coordinate and assign the color of that vertex to our sample.</li>
				<li><code>sample_bilinear()</code>: This means we will find the four nearest vertices on the texture to
					the sample texture coordinate and use trilinear interpolation to calculate the color of the sample.
				</li>
			</ul>
		</li>
	</ul>
	<p><b>2. Image Gallery</b></p>
	<figcaption><b>Nearest Sampling + Sampling Rate = 1</b></figcaption>
	<img src="image_3.png" alt="Nearest Sampling + Sampling Rate = 1">
	<figcaption><b>Nearest Sampling + Sampling Rate = 16</b></figcaption>
	<img src="image_4.png" alt="Nearest Sampling + Sampling Rate = 16">
	<figcaption><b>Bilinear Sampling + Sampling Rate = 1</b></figcaption>
	<img src="image_5.png" alt="Bilinear Sampling + Sampling Rate = 1">
	<figcaption><b>Bilinear Sampling + Sampling Rate = 16</b></figcaption>
	<img src="image_6.png" alt="Bilinear Sampling + Sampling Rate = 16">
	<p><b>3. Difference between two sampling methods</b></p>
	<ul>
		<li>When the sample rate is low, there will be a large difference between those two methods and we should use
			the bilinear sampling method. Since the number of samples we have is small, we need bilinear sampling to
			make use of the colors of other points on the texture to make the image seem smooth. If we only make use of
			the nearest point on the texture, the image may look sharp.</li>
		<li>When the sample rate is high, we can use either bilinear sampling or nearest sampling. Since the number of
			samples we have is large, even if each sample is assigned with the color value nearest to it, it will still
			create a smooth vision effect.</li>
	</ul>

</body>

</html>